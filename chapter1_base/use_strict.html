<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

</body>
<script>
  /**
   主要关心没注意到的地方
   1.严格模式：
            "use strict" 可以放在文件上，或者方法内

            第一，严格模式下无法再意外创建全局变量。在普通的JavaScript里面给一个错误命名的变量名赋值会使全局对象新增一个属性并继续“工作”
            （尽管将来可能会失败：在现代的JavaScript中有可能）。严格模式中意外创建全局变量被抛出错误替代：

                    "use strict";
                                        // 假如有一个全局变量叫做mistypedVariable
                    mistypedVaraible = 17; // 因为变量名拼写错误
                                        // 这一行代码就会抛出 ReferenceError

             第二,严格模式会使引起静默失败(silently fail,注:不报错也没有任何效果)的赋值操作抛出异常. 例如, NaN 是一个不可写的全局变量. 
             在正常模式下, 给 NaN 赋值不会产生任何作用; 开发者也不会受到任何错误反馈. 
             但在严格模式下, 给 NaN 赋值会抛出一个异常. 任何在正常模式下引起静默失败的赋值操作 (给不可写属性赋值, 给只读属性(getter-only)赋值赋值, 
             给不可扩展对象(non-extensible object)的新属性赋值) 都会抛出异常:

                "use strict";

                    // 给不可写属性赋值
                    var obj1 = {};
                    Object.defineProperty(obj1, "x", { value: 42, writable: false });
                    obj1.x = 9; // 抛出TypeError错误

                    // 给只读属性赋值
                    var obj2 = { get x() { return 17; } };
                    obj2.x = 5; // 抛出TypeError错误

                    // 给不可扩展对象的新属性赋值
                    var fixed = {};
                    Object.preventExtensions(fixed);
                    fixed.newProp = "ohai"; // 抛出TypeError错误

            第三, 在严格模式下, 试图删除不可删除的属性时会抛出异常(之前这种操作不会产生任何效果):

                "use strict";
                delete Object.prototype; // 抛出TypeError错误

            第四，在Gecko版本34之前，严格模式要求一个对象内的所有属性名在对象内必须唯一。
            正常模式下重名属性是允许的，最后一个重名的属性决定其属性值。因为只有最后一个属性起作用，当代码要去改变属性值而不是修改最后一个重名属性的时候，
            复制这个对象就产生一连串的bug。在严格模式下，重名属性被认为是语法错误：

                这个问题在ECMAScript6中已经不复存在(bug 1041128)。

                "use strict";
                var o = { p: 1, p: 2 }; // !!! 语法错误

            第五, 严格模式要求函数的参数名唯一. 在正常模式下,
             最后一个重名参数名会掩盖之前的重名参数. 之前的参数仍然可以通过 arguments[i] 来访问,
              还不是完全无法访问. 然而, 这种隐藏毫无意义而且可能是意料之外的 (比如它可能本来是打错了), 所以在严格模式下重名参数被认为是语法错误:

                function sum(a, a, c) { // !!! 语法错误
                "use strict";
                return a + a + c; // 代码运行到这里会出错
                }
            
            第六, 严格模式禁止八进制数字语法. ECMAScript并不包含八进制语法, 
            但所有的浏览器都支持这种以零(0)开头的八进制语法: 0644 === 420 还有 "\045" === "%".在ECMAScript 6中支持为一个数字加"0o"的前缀来表示八进制数.

                var a = 0o10; // ES6: 八进制
                有些新手开发者认为数字的前导零没有语法意义, 所以他们会用作对齐措施 — 但其实这会改变数字的意义! 八进制语法很少有用并且可能会错误使用, 所以严格模式下八进制语法会引起语法错误:

                "use strict";
                var sum = 015 + // !!! 语法错误
                        197 +
                        142;
            
            第七，ECMAScript 6中的严格模式禁止设置primitive值的属性.不采用严格模式,设置属性将会简单忽略(no-op),采用严格模式,将抛出TypeError错误

                (function() {
                "use strict";

                false.true = "";              //TypeError
                (14).sailing = "home";        //TypeError
                "with".you = "far away";      //TypeError
                })();

            还有一些看不懂的。
  */  

</script>
</html>