<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // ECMAScript 中有两种属性：数据属性和访问器属性。

    // 1.数据属性包含一个数据值的位置，有4个描述行为的特性

    //  [[Configurable]] ：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特
    // 性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的
    // 这个特性默认值为 true 。
    //  [[Enumerable]] ：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定
    // 义的属性，它们的这个特性默认值为 true 。
    //  [[Writable]] ：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的
    // 这个特性默认值为 true 。
    //  [[Value]] ：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，
    // 把新值保存在这个位置。这个特性的默认值为 undefined 。

    //     [[Value]] 特性将
    // 被设置为 "Nicholas"
    var person = {
        name: "Nicholas"
    };
    // 要修改属性默认的特性，必须使用 ECMAScript 5 的 Object.defineProperty() 方法  
    var person = {};
    Object.defineProperty(person, "name", {
        writable: false,
        value: "Nicholas"
    });
    console.log(person.name);
    person.name = "greg";//严格模式这里会报错
    console.log(person.name);


    Object.defineProperty(person, "name", {
        configurable: false,
        value: "Nicholas"
    });
    console.log(person.name); //"Nicholas"
    delete person.name;//把 configurable 设置为 false ，表示不能从对象中删除属性
    console.log(person.name); //"Nicholas"
    //     而且，一旦把属性定义为不可配置的，
    // 就不能再把它变回可配置了。此时，再调用 Object.defineProperty() 方法修改除 writable 之外
    // 的特性，都会导致错误

    //抛出错误
    // Object.defineProperty(person, "name", {
    //     configurable: true,
    //     value: "Nicholas"
    // });
    //     如果不指定， configurable 、 enumerable 和
    // writable 特性的默认值都是 false 。多数情况下，可能都没有必要利用 Object.defineProperty()
    // 方法提供的这些高级功能。不过，理解这些概念对理解 JavaScript 对象却非常有用。


    //2.访问器属性：
    // 访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数
    //  [[Configurable]] ：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特
    // 性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为
    // true 。
    //  [[Enumerable]] ：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这
    // 个特性的默认值为 true 。
    //  [[Get]] ：在读取属性时调用的函数。默认值为 undefined 。
    //  [[Set]] ：在写入属性时调用的函数。默认值为 undefined 。

    var book = {
        _year: 2004,
        edition: 1
    };
    Object.defineProperty(book, "year", {
        get: function () {
            return this._year;
        },
        set: function (newValue) {
            if (newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    });
    book.year = 2005;
    console.log(book.edition); //2

    //定义多个属性
    var book = {};
    Object.defineProperties(book, {
        _year: {
            value: 2004
        },
        edition: {
            value: 1
        },
        year: {
            get: function () {
                return this._year;
            },
            set: function (newValue) {
                if (newValue > 2004) {
                    this._year = newValue;
                    this.edition += newValue - 2004;
                }
            }
        }
    });
    console.log("_year:"+book._year);
    // 以上代码在 book 对象上定义了两个数据属性（ _year 和 edition ）和一个访问器属性（ year ）。

    // 使用 ECMAScript 5 的 Object.getOwnPropertyDescriptor() 方法，可以取得给定属性的描述
    // 符。     
    var descriptor = Object.getOwnPropertyDescriptor(book, "_year");
    console.log(descriptor.value); //2004
    console.log(descriptor.configurable); //false
    console.log(typeof descriptor.get);//undefined
    descriptor = Object.getOwnPropertyDescriptor(book, "year");
    console.log(descriptor.value); //undefied
    console.log(descriptor.enumerable); //false
    console.log(typeof descriptor.get);//funtion

    //2 创建对象：
        // 工厂：
     function createPerson(name,age,job){
         var o = new Object();
         o.name = name;
         o.age = age;
         o.job = job;
         o.sayName = function(){
             console.log(name);
         };
         return o;
     }

     var perosn1 = createPerson("tom",23,"engineer");
       //构造函数
     function Person(name,age,job){
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function(){
             console.log(name);
         };
     }

     var perons2 =  new Person("jack",21,"teacher");
     //构造函数：1.没有显示的创建对象,2.直接赋值给this 3.没有return
     //用new Person会经历4个步骤
     /**
        1.创建一个新对象。
        2.将构造函数的作用域赋值给新对象。因此this指向新对象
        3.执行构造函数代码
        4.返回新对象。
     */
     console.log(perons2 instanceof Person);

     //任何函数，用new 调用。就是构造函数。
     Person("test,",213,"test");
     window.sayName();

     var o1 = new Object();
     Person.call(o1,"kkk",23,"333");
     o1.sayName();
     //创建的方法也是对象。。虽然他们的逻辑一样；
    //  用以下方法可以避免重复创建
    function Customer(name){
        this.name = name;
        this.sayName = ConsoleName;
    }
    function ConsoleName(){
        console.log(this.name);
    }

    var cus1 = new Customer("to");
    var cus2 = new Customer("go");
    cus1.sayName();
    cus2.sayName();
    console.log(cus1.sayName == cus2.sayName);

    //用上列也不是个好方法。
    // 原型模式：
    function PersonNew(){
    }
    // PersonNew.prototype.name = 
    
</script>

</html>